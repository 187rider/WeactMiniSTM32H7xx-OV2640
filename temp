#include "fatfs.h"
#include "stdio.h"
#include "string.h"
#include "main.h"
#include "i2c.h"
#include "camera.h"
#include "lcd.h"

extern uint32_t photo_id;
extern volatile uint32_t DCMI_FrameIsReady;
extern volatile uint32_t DCMI_CallbackCount;

#define MAX_PICTURE_BUFF (100*2048)
 //uint8_t pBuff[MAX_PICTURE_BUFF];
// DMA-accessible buffer for JPEG capture, placed in AXI SRAM (.sram1)
__attribute__((section(".sram1"))) static uint8_t pBuff[MAX_PICTURE_BUFF];
//uint8_t pBuff[MAX_PICTURE_BUFF] __attribute__((aligned(32)));
uint8_t take_A_Picture(DCMI_HandleTypeDef *hdcmi)
{
    FIL file;
    FRESULT res;
    uint32_t f_begin = 0, f_end = 0, sublen;
    uint16_t f_count, r;
    UINT bw;
    uint8_t picture_ok = 0;
    uint8_t headerFinder = 0;
    char msg[50];

    char fn[32];
    sprintf(fn, "photo_%lu.jpg", photo_id++);
    LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"Creating file...");

    res = f_open(&file, fn, FA_CREATE_ALWAYS | FA_WRITE);
    if(res != FR_OK) {
        sprintf(msg, "SD Error: %d", res);
        LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);
        return 0;
    }

    // Stop any ongoing capture
    HAL_DCMI_Stop(hdcmi);
    HAL_Delay(50);
    
    // Clear flags BEFORE camera init
    DCMI_FrameIsReady = 0;
    DCMI_CallbackCount = 0;
    
    // Initialize camera in JPEG mode
    Camera_Picture_Device(&hi2c1);
    LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"Init camera...");
    HAL_Delay(500);  // Camera needs time to settle
    
    // Clear buffer
    memset(pBuff, 0, MAX_PICTURE_BUFF);
    
    // **USE VSYNC INTERRUPT INSTEAD OF FRAME**
    // Clear all interrupts first
    hdcmi->Instance->ICR = DCMI_IT_FRAME | DCMI_IT_OVR | DCMI_IT_ERR | DCMI_IT_LINE | DCMI_IT_VSYNC;
    HAL_Delay(10);
    
    // Enable only VSYNC interrupt for frame synchronization
    __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_VSYNC);
    DCMI_FrameIsReady = 0;  // We'll reuse this flag for VSYNC

    LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"Starting DMA...");
    
    // **USE SNAPSHOT MODE** (not CONTINUOUS for single frame capture)
    if(HAL_DCMI_Start_DMA(hdcmi, DCMI_MODE_SNAPSHOT, (uint32_t)pBuff, MAX_PICTURE_BUFF / 4) != HAL_OK) {
        LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"DMA Start Failed");
        f_close(&file);
        return 0;
    }
    
    LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"Waiting VSYNC...");
    
    // Wait for VSYNC with timeout
    uint32_t timeout = 0;
    while(DCMI_FrameIsReady == 0) {
        if(timeout % 200 == 0) {
            sprintf(msg, "Waiting VSYNC T:%lu", timeout);
            LCD_ShowString(0, 62, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);
        }
        
        if(timeout++ > 3000) {  // 3 second timeout for VSYNC
            sprintf(msg, "VSYNC Timeout! CB:%lu", DCMI_CallbackCount);
            LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);
            HAL_DCMI_Stop(hdcmi);
            f_close(&file);
            HAL_Delay(3000);
            return 0;
        }
        HAL_Delay(1);
    }

    // VSYNC detected - wait a bit more for frame completion
    LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"VSYNC OK - Capturing...");
    HAL_Delay(50);  // Wait for frame data to be transferred
    
    HAL_DCMI_Stop(hdcmi);
    HAL_Delay(10);

    LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"Scanning buffer...");

    // Check first few bytes
    sprintf(msg, "First bytes: %02X %02X %02X %02X", pBuff[0], pBuff[1], pBuff[2], pBuff[3]);
    LCD_ShowString(0, 62, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);
    HAL_Delay(1000);

    // Scan for JPEG markers
    for(uint32_t idx = 0; idx < MAX_PICTURE_BUFF - 1; idx++) {
        if(headerFinder == 0 && pBuff[idx] == 0xFF && pBuff[idx+1] == 0xD8) {
            headerFinder = 1;
            f_begin = idx;
            sprintf(msg, "SOI at: %lu", f_begin);
            LCD_ShowString(0, 74, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);
        }
        if(headerFinder == 1 && pBuff[idx] == 0xFF && pBuff[idx+1] == 0xD9) {
            f_end = idx + 1;
            picture_ok = 1;
            sprintf(msg, "EOI at: %lu", f_end);
            LCD_ShowString(0, 86, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);

            uint8_t *buff = pBuff + f_begin;
            sublen = f_end - f_begin + 1;

            sprintf(msg, "Size: %lu bytes", sublen);
            LCD_ShowString(0, 98, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);

            f_count = sublen / 512;
            r = sublen % 512;

            for(int i = 0; i < f_count; i++) {
                res = f_write(&file, buff, 512, &bw);
                if(res != FR_OK || bw != 512) {
                    sprintf(msg, "Write err: %d", res);
                    LCD_ShowString(0, 110, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);
                }
                buff += 512;
            }
            if(r > 0) {
                res = f_write(&file, buff, r, &bw);
                if(res != FR_OK || bw != r) {
                    sprintf(msg, "Final write err: %d", res);
                    LCD_ShowString(0, 110, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);
                }
            }
            break;
        }
    }

    f_close(&file);

    if(!picture_ok) {
        LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"No JPEG markers!");
        // Debug: Check buffer content
        uint32_t non_zero = 0;
        for(uint32_t i = 0; i < 1000; i++) {
            if(pBuff[i] != 0) non_zero++;
        }
        sprintf(msg, "Non-zero: %lu/1000", non_zero);
        LCD_ShowString(0, 62, ST7735Ctx.Width, 5, 12, (uint8_t*)msg);
    } else {
        LCD_ShowString(0, 50, ST7735Ctx.Width, 5, 12, (uint8_t*)"Picture saved!");
    }
    
    HAL_Delay(2000);

    while(HAL_GPIO_ReadPin(KEY_GPIO_Port, KEY_Pin) == GPIO_PIN_RESET) HAL_Delay(10);

    return picture_ok;
}
